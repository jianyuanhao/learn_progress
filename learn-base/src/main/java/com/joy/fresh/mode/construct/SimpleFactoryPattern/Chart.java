//package com.joy.fresh.mode.construct.SimpleFactoryPattern;
//
///**
// * 定义：
// * 简单工厂模式(Simple Factory Pattern)：定义一个工厂类，
// * 它可以根据参数的不同返回不同类的实例，
// * 被创建的实例通常都具有共同的父类。
// * 因为在简单工厂模式中用于创建实例的方法是静态(static)方法，
// * 因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，
// * 它属于类创建型模式。
// *要点：
// * 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，
// * 就可以获取你所需要的对象，而无须知道其创建细节。
// * 简单工厂模式结构比较简单，其核心是工厂类的设计，其结构如图1所示：
// * Created by jianyuanhao on 18-8-7.
// * 问题：
// * (1)
// * 在Chart类中包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；
// * 而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断。
// *
// * (2) Chart类的职责过重，它负责初始化和显示所有的图表对象，将各种图表对象的初始化代码和显示代码集中在一个类中实现，
// * 违反了“单一职责原则”，不利于类的重用和维护；而且将大量的对象初始化代码都写在构造函数中将导致构造函数非常庞大，
// * 对象在创建时需要进行条件判断，降低了对象创建的效率。
// *
// * (3) 当需要增加新类型的图表时，必须修改Chart类的源代码，违反了“开闭原则”。
// *
// * (4) 客户端只能通过new关键字来直接创建Chart对象，Chart类与客户端类耦合度较高，对象的创建和使用无法分离。
// *
// * (5)客户端在创建Chart对象之前可能还需要进行大量初始化设置，例如设置柱状图的颜色、高度等，如果在Chart类的构造函数中
// * 没有提供一个默认设置，那就只能由客户端来完成初始设置，这些代码在每次创建Chart对象时都会出现，导致代码的重复。
// *
// * 面对一个如此巨大、职责如此重，且与客户端代码耦合度非常高的类，我们应该怎么办？本章将要介绍的简单工厂模式将在一定
// * 程度上解决上述问题。
// *方案：
// * 首先将需要创建的各种不同对象（例如各种不同的Chart对象）的相关代码封装到不同的类中，这些类称为具体产品类
// * 而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；
// * 然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；
// * 客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。
// */
//public class Chart {
//    private String type; // 图表类型
//
//    public Chart(Object[][] data, String type) {
//        this.type = type;
//        if (type.equalsIgnoreCase("histogram")) {
//            // 初始化柱状图
//        } else if (type.equalsIgnoreCase("pie")) {
//            // 初始化饼状图
//        } else if (type.equalsIgnoreCase("line")) {
//            // 初始化折线图
//        }
//    }
//
//    public void display() {
//        if (this.type.equalsIgnoreCase("histogram")) {
//            // 显示柱状图
//        } else if (this.type.equalsIgnoreCase("pie")) {
//            // 显示饼状图
//        } else if (this.type.equalsIgnoreCase("line")) {
//            // 显示折线图
//        }
//    }
//
//}
